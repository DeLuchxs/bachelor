\chapter{Implementierung}
\printmyminitoc{1}

\section{Umsetzung des Rogue Device}
Wie vorher schon beschrieben, wird ein Raspberry Pi 5 als Rogue Device benutzt. 
Als Betriebssystem wird Raspberry Pi OS benutzt. Dieses Betriebssystem ist eine auf Debian basierende Distribution, 
die speziell für den Raspberry Pi entwickelt wurde. Da der Raspberry Pi mit Linux betrieben wird, ist es die Bedienung
vergleichbar mit einem normalen Linux-System. Der Standard Package Manager ist apt. Unter dessen Benutzung werden 
Python 3.12 und die benötigten Bibliotheken installiert. Damit sind die Vorraussetzungen für die weitere Implementierung
gesetzt.

\section{Verbindung Rogue Device - Controller}
\begin{itemize}
    \item benutzt wird Python 3.12.8, da einfache Syntax und gute Bibliotheken
    \item Bibliothek: Pygame für die Controllereingabe (https://www.pygame.org/docs/(abgerufen am 08.12.2024))
    \item Beispielscode für Pygame: \href{https://github.com/kevinmcaleer/xbox_controller}{github} (abgerufen am 08.12.2024)
\end{itemize}

Im ersten Schritt wird der Controller mit dem Raspberry Pi verbunden. Der Raspberry Pi wird mit Raspberry Pi OS betrieben. 
Dieses Betriebssystem ist eine auf Debian basierende Distribution, die speziell für den Raspberry Pi entwickelt wurde.
Als Standard-Bluetooth-Treiber wird \href{https://www.bluez.org/}{BlueZ} verwendet. Dieser ist bereits vorinstalliert und muss 
nicht extra installiert werden. Da es sich in diesem Fall um einen XBox Controllers handelt, müssen die richtigen Treiber
(\href{https://github.com/xboxdrv/xboxdrv}{xboxdrv}) installiert werden. Diese können im apt-Repository gefunden werden.
Zusätzlich muss der Enhanced Re-Transmission Mode (ERTM) deaktiviert werden. Dieser Modus ist standardmäßig aktiviert und
verhindert die korrekte Verbindung des Controllers. Zum Schluss soll der Controller auf die aktuelle Firmware geupdatet werden.
Dies kann über die Xbox Accessories App gemacht werden, allerdings ist dies nur auf Windows möglich. Nun kann 
der Controller mit dem Raspberry Pi verbunden werden. Dies geschieht über die Bluetooth-Einstellungen des Raspberry Pi.
Um die Verbindung zu testen, kann eine Webapplikation benutzt werden. Diese zeigt die Eingaben des Controllers an. Zum 
Beispiel: \href{https://hardwaretester.com/gamepad}{hardwaretester} (abgerufen am 02.01.2025) 
\\
Als Programmiersprache wird Python 3 benutzt. Dies ist eine einfache Sprache, die viele Bibliotheken hat. Für die
Controller-Eingaben wird die Bibliothek Pygame benutzt. Diese Bibliothek ist einfach zu benutzen und hat viele Funktionen.
Sobald der Controller mit dem Raspberry Pi verbunden ist, wird dieser von Pygame erkannt. Die Eingaben des Controllers
können dann in Variablen gespeichert werden. Dabei gilt es zu beachten, dass der Gashebel oder die Ruderposition nicht
zu schnell verändert werden. Dies könnte zu unerwünschten Ergebnissen führen. Daher werden diese Werte mit Tasten des
Controllers eingegeben, welche nicht nur eine binäre Eingabe haben. Diese werden als Achsen bezeichnet. Diese ermöglichen
eine stufenlose Eingabe. Bei einer vollständigen Eingabe soll die Gashebelposition nach 20 Sekunden 100\% erreichen.
So ist sichergestellt, dass die Gashebelposition nicht zu schnell verändert wird. Die Ruderposition soll nach 2 Sekunden
in jede Richtung jeweils 100\% erreichen. Dies ist ein Kompromiss zwischen Geschwindigkeit und Genauigkeit.


Benutzte Hardware, Protokolle, Libraries 

\section{Übersetzung Signale Controller - Schiff}
Welches Dateiformat wird für Controllersignale benutzt?
Wie werden diese effizient genug in Motorsignale übersetzt?
Kann ich einfach originale Steuerungssignale unterdrücken?

Es gibt zuerst ein Programm, welches die Signale des Controllers erhält und in passende Variablen in Python interpretiert. Diese Variablen müssen
dann in Nachrichten für den Can-Bus umgewandelt werden. Hierfür gibt es ein weiteres Programm. Damit die beiden Programme miteinander kommunizieren
können, wird Inter-Process-Communication (IPC) benutzt. Als Methode werden hierbei Pipes benutzt. Diese sind einfach zu implementieren und haben
eine automatische Synchronisierung zwischen den Prozessen. Das bedeutet, dass die Prozesse nicht aufeinander warten müssen, sondern einfach
weiterarbeiten können. Es wird durch den Puffer der Pipe sichergestellt. Wenn dieser voll ist, wird der schreibende Prozess angehalten, bis der
lesende Prozess den Puffer geleert hat. Dies ist ein einfaches und effizientes Verfahren, 
um die beiden Prozesse zu synchronisieren \cite{Venkataraman2015}. 

\begin{itemize}
    \item Anfangsbeispiel: \href{https://www.geeksforgeeks.org/inter-process-communication-ipc/}{geeksforgeeks} (abgerufen am 18.12.2024)
    \item Python: \href{https://thelinuxcode.com/python-pipe-example/}{thelinuxcode} (abgerufen am 19.12.2024)
    \item encoding von canbus nachrichten in Python: \href{https://cantools.readthedocs.io/en/latest/}{cantools}
\end{itemize}

\begin{itemize}
    \item encoding mit cantools
    \item signal definieren
    \item message erstellen
    \item mit beispiel dbc datei und encoden
    \item decoder für canbus nachrichten (vor allem zum testen, aber auch für reaktion auf gashebel) (cantools)
    \item dbc Datei verstehen \href{https://www.csselectronics.com/pages/can-dbc-file-database-intro}{csselectronics}
    \item checksum berechnet nach \href{https://www.vector.com/de/de/know-how/protokolle/sae-j1939/#c103447}{vector} (abgerufen am 07.02.2025)
\end{itemize}

\section{Eingabe-Interface}
Wie wird die Rückmeldung tatsächlich aussehen?